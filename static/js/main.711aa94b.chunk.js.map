{"version":3,"sources":["Component/Canvas/Canvas.js","App.js","reportWebVitals.js","index.js"],"names":["Canvas","CheckForSpaces","inGrid","width","height","currentPos","availableSpaces","x","y","push","useEffect","imageData","prevPositions","canvas","ctx","colorSteps","grid","colors","document","getElementById","getContext","createImageData","colorObj","r","g","b","Math","floor","random","notFilled","length","test","colorPop","pop","data","putImageData","drawImageToCanvas","id","App","className","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.711aa94b.chunk.js","sourcesContent":["import React,{ useEffect } from 'react';\n\nfunction Canvas(){\n\n    \n\n    \n  \n   \n    function CheckForSpaces(inGrid,width,height,currentPos) //Checks for available spaces then returns back all available spaces\n    {\n        let availableSpaces = [];\n        \n        if(currentPos.x > 0)\n        {\n            if(inGrid[currentPos.x - 1][currentPos.y] === 0)\n            {\n                availableSpaces.push({x:currentPos.x - 1, y:currentPos.y});\n            }\n        }\n        else if(inGrid[width - 1][currentPos.y] === 0)\n        {\n            availableSpaces.push({x:width - 1, y:currentPos.y});\n        }\n        \n        if(currentPos.x < width - 1)\n        {\n            if(inGrid[currentPos.x + 1][currentPos.y] === 0)\n            {\n                availableSpaces.push({x:currentPos.x + 1, y:currentPos.y});\n            }\n        }\n        else if(inGrid[0][currentPos.y] === 0)\n        {\n            availableSpaces.push({x:0, y:currentPos.y});\n        }\n        \n        if(currentPos.y > 0)\n        {\n            if(inGrid[currentPos.x][currentPos.y - 1] === 0)\n            {\n                availableSpaces.push({x:currentPos.x, y:currentPos.y - 1});\n            }\n        }\n        else if(inGrid[currentPos.x][height - 1] === 0)\n        {\n            availableSpaces.push({x:currentPos.x,y: height - 1});\n        }\n        \n        if(currentPos.y < height - 1)\n        {\n            if(inGrid[currentPos.x][currentPos.y + 1] === 0)\n            {\n                availableSpaces.push({x:currentPos.x,y: currentPos.y + 1});\n            }\n        }\n        else if(inGrid[currentPos.x][0] === 0)\n        {\n            availableSpaces.push({x:currentPos.x, y:0});\n        }\n        //  console.log(availableSpaces)\n        return availableSpaces;\n    }\n    \n    \n  useEffect(() => {\n    let canvas = null;\n    let ctx = null;\n    let width; //canvas width\n    let height; //canvas height\n    let imageData;\n    let currentPos;\n    let prevPositions;\n      \n    let colorSteps = 32;\n   \n   \n    let grid=[];\n    let colors = []; //Array of all colors\n\n  \n    let drawImageToCanvas =()=>\n    {\n      \n        canvas = document.getElementById('canvas'); // Get the HTML element with the ID of 'canvas'\n        width = canvas.width;\n        height = canvas.height;\n        ctx = canvas.getContext('2d'); // This is necessary, but I don't know exactly what it does\n        \n        imageData = ctx.createImageData(width,height); //Needed to do pixel manipulation\n        \n       \n       \n        prevPositions = []; //Array of previous positions, used for the recursive backtracker algorithm\n        let colorObj ={}\n        for(let r = 0; r < colorSteps; r++)\n        {\n            for(let g = 0; g < colorSteps; g++)\n            {\n                for(let b = 0; b < colorSteps; b++)\n                {\n                    colorObj={\n                        r:Math.floor(r * 255 / (colorSteps - 1)),\n                        g:Math.floor(g * 255 / (colorSteps - 1)),\n                        b:Math.floor(b * 255 / (colorSteps - 1))\n                    }\n                    colors.push(colorObj)\n                    \n                }\n            }\n        }\n        \n  \n        for(let x = 0; x < width; x++)\n        {\n            grid.push([]);\n            for(let y = 0; y < height; y++)\n            {\n                grid[x].push(0); //Set up the grid\n              \n            }\n        }\n       \n        currentPos = {x:Math.floor(Math.random() * width),y:Math.floor(Math.random() * height)}; \n        \n        grid[currentPos.x][currentPos.y] = 1;\n       \n        prevPositions.push(currentPos);\n                  \n            do\n            {\n                let notFilled = true;\n                while(notFilled)\n                {\n                     let availableSpaces = CheckForSpaces(grid,width,height,currentPos);\n                    \n                    if(availableSpaces.length > 0)\n                    {\n                         let test = availableSpaces[Math.floor(Math.random() * availableSpaces.length)];\n                         prevPositions.push(currentPos);\n                         currentPos = test;\n                         grid[currentPos.x][currentPos.y] = 1;\n                        let colorPop =colors && colors.pop()\n                        // console.log(colorPop)\n                        imageData.data[((currentPos.x + (currentPos.y * width)) * 4) + 0] = colorPop.r;\n                        imageData.data[((currentPos.x + (currentPos.y * width)) * 4) + 1] = colorPop.g;\n                        imageData.data[((currentPos.x + (currentPos.y * width)) * 4) + 2] = colorPop.b;\n                        imageData.data[((currentPos.x + (currentPos.y * width)) * 4) + 3] = 255;\n                       \n                        notFilled = false;\n                    }\n                    else\n                    {\n                        if(prevPositions.length !==0)\n                        {\n                            currentPos = prevPositions.pop();\n                        }\n                        else\n                        {\n                            break;\n                        }\n                    }\n                }\n            }\n            while(prevPositions.length > 0)\n            ctx.putImageData(imageData,0,0);\n        \n       \n    }\n    \n    drawImageToCanvas();\n  }, []);\n\n  return (\n    <div>\n<canvas id=\"canvas\" width=\"256\" height=\"128\">\n        Sorry your browser does not support Canvas, try Firefox or Chrome!\t\n    </canvas>\n  </div>\n  )\n}\n\n\nexport default Canvas;\n","\nimport './App.css';\n\n import Canvas from './Component/Canvas';\n\nfunction App() {\n  return (\n    <div className=\"App\">\n     \n      <Canvas/>\n    </div>\n  );\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}
{"version":3,"sources":["Component/Canvas/Canvas.js","App.js","reportWebVitals.js","index.js"],"names":["Canvas","currentPos","prevPositions","width","height","imageData","canvas","ctx","colorSteps","grid","colors","CheckForSpaces","inGrid","availableSpaces","x","y","push","useEffect","document","getElementById","getContext","createImageData","colorObj","r","g","b","Math","floor","random","notFilled","length","test","colorPop","pop","data","putImageData","drawImageToCanvas","id","App","className","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.0e5a8388.chunk.js","sourcesContent":["import React,{ useEffect } from 'react';\n\nfunction Canvas(){\n\n    let canvas = null;\n    let ctx = null;\n\n    let currentPos;\n    let prevPositions;\n    let colorSteps = 32;\n    let width; //canvas width\n    let height; //canvas height\n    let imageData;\n    let grid=[];\n    let colors = []; //Array of all colors\n\n    let drawImageToCanvas =()=>\n    {\n      \n        canvas = document.getElementById('canvas'); // Get the HTML element with the ID of 'canvas'\n        width = canvas.width;\n        height = canvas.height;\n        ctx = canvas.getContext('2d'); // This is necessary, but I don't know exactly what it does\n        \n        imageData = ctx.createImageData(width,height); //Needed to do pixel manipulation\n        \n       \n       \n        prevPositions = []; //Array of previous positions, used for the recursive backtracker algorithm\n        let colorObj ={}\n        for(let r = 0; r < colorSteps; r++)\n        {\n            for(let g = 0; g < colorSteps; g++)\n            {\n                for(let b = 0; b < colorSteps; b++)\n                {\n                    colorObj={\n                        r:Math.floor(r * 255 / (colorSteps - 1)),\n                        g:Math.floor(g * 255 / (colorSteps - 1)),\n                        b:Math.floor(b * 255 / (colorSteps - 1))\n                    }\n                    colors.push(colorObj)\n                    \n                }\n            }\n        }\n        \n  \n        for(let x = 0; x < width; x++)\n        {\n            grid.push([]);\n            for(let y = 0; y < height; y++)\n            {\n                grid[x].push(0); //Set up the grid\n              \n            }\n        }\n       \n        currentPos = {x:Math.floor(Math.random() * width),y:Math.floor(Math.random() * height)}; \n        \n        grid[currentPos.x][currentPos.y] = 1;\n       \n        prevPositions.push(currentPos);\n                  \n            do\n            {\n                let notFilled = true;\n                while(notFilled)\n                {\n                     let availableSpaces = CheckForSpaces(grid);\n                    \n                    if(availableSpaces.length > 0)\n                    {\n                         let test = availableSpaces[Math.floor(Math.random() * availableSpaces.length)];\n                         prevPositions.push(currentPos);\n                         currentPos = test;\n                         grid[currentPos.x][currentPos.y] = 1;\n                        let colorPop =colors && colors.pop()\n                        // console.log(colorPop)\n                        imageData.data[((currentPos.x + (currentPos.y * width)) * 4) + 0] = colorPop.r;\n                        imageData.data[((currentPos.x + (currentPos.y * width)) * 4) + 1] = colorPop.g;\n                        imageData.data[((currentPos.x + (currentPos.y * width)) * 4) + 2] = colorPop.b;\n                        imageData.data[((currentPos.x + (currentPos.y * width)) * 4) + 3] = 255;\n                       \n                        notFilled = false;\n                    }\n                    else\n                    {\n                        if(prevPositions.length !==0)\n                        {\n                            currentPos = prevPositions.pop();\n                        }\n                        else\n                        {\n                            break;\n                        }\n                    }\n                }\n            }\n            while(prevPositions.length > 0)\n            ctx.putImageData(imageData,0,0);\n        \n       \n    }\n    \n   \n    function CheckForSpaces(inGrid) //Checks for available spaces then returns back all available spaces\n    {\n        let availableSpaces = [];\n        \n        if(currentPos.x > 0)\n        {\n            if(inGrid[currentPos.x - 1][currentPos.y] === 0)\n            {\n                availableSpaces.push({x:currentPos.x - 1, y:currentPos.y});\n            }\n        }\n        else if(inGrid[width - 1][currentPos.y] === 0)\n        {\n            availableSpaces.push({x:width - 1, y:currentPos.y});\n        }\n        \n        if(currentPos.x < width - 1)\n        {\n            if(inGrid[currentPos.x + 1][currentPos.y] === 0)\n            {\n                availableSpaces.push({x:currentPos.x + 1, y:currentPos.y});\n            }\n        }\n        else if(inGrid[0][currentPos.y] === 0)\n        {\n            availableSpaces.push({x:0, y:currentPos.y});\n        }\n        \n        if(currentPos.y > 0)\n        {\n            if(inGrid[currentPos.x][currentPos.y - 1] === 0)\n            {\n                availableSpaces.push({x:currentPos.x, y:currentPos.y - 1});\n            }\n        }\n        else if(inGrid[currentPos.x][height - 1] === 0)\n        {\n            availableSpaces.push({x:currentPos.x,y: height - 1});\n        }\n        \n        if(currentPos.y < height - 1)\n        {\n            if(inGrid[currentPos.x][currentPos.y + 1] === 0)\n            {\n                availableSpaces.push({x:currentPos.x,y: currentPos.y + 1});\n            }\n        }\n        else if(inGrid[currentPos.x][0] === 0)\n        {\n            availableSpaces.push({x:currentPos.x, y:0});\n        }\n        //  console.log(availableSpaces)\n        return availableSpaces;\n    }\n    \n    \n  useEffect(() => {\n    drawImageToCanvas();\n  }, []);\n\n  return (\n    <div>\n<canvas id=\"canvas\" width=\"256\" height=\"128\">\n        Sorry your browser does not support Canvas, try Firefox or Chrome!\t\n    </canvas>\n  </div>\n  )\n}\n\n\nexport default Canvas;\n","\nimport './App.css';\n\n import Canvas from './Component/Canvas';\n\nfunction App() {\n  return (\n    <div className=\"App\">\n     \n      <Canvas/>\n    </div>\n  );\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}
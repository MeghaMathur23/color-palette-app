{"version":3,"sources":["Component/Canvas/Canvas.js","App.js","reportWebVitals.js","index.js"],"names":["Canvas","currentPos","prevPositions","imageData","colorSteps","grid","colors","CheckForSpaces","inGrid","width","height","availableSpaces","x","y","push","useEffect","canvas","ctx","document","getElementById","getContext","createImageData","colorObj","r","g","b","Math","floor","random","notFilled","length","test","colorPop","pop","data","putImageData","drawImageToCanvas","id","App","className","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.9d488c35.chunk.js","sourcesContent":["import React,{ useEffect } from 'react';\n\nfunction Canvas(){\n\n    \n\n    let currentPos;\n    let prevPositions;\n    let colorSteps = 32;\n   \n    let imageData;\n    let grid=[];\n    let colors = []; //Array of all colors\n\n  \n   \n    function CheckForSpaces(inGrid,width,height) //Checks for available spaces then returns back all available spaces\n    {\n        let availableSpaces = [];\n        \n        if(currentPos.x > 0)\n        {\n            if(inGrid[currentPos.x - 1][currentPos.y] === 0)\n            {\n                availableSpaces.push({x:currentPos.x - 1, y:currentPos.y});\n            }\n        }\n        else if(inGrid[width - 1][currentPos.y] === 0)\n        {\n            availableSpaces.push({x:width - 1, y:currentPos.y});\n        }\n        \n        if(currentPos.x < width - 1)\n        {\n            if(inGrid[currentPos.x + 1][currentPos.y] === 0)\n            {\n                availableSpaces.push({x:currentPos.x + 1, y:currentPos.y});\n            }\n        }\n        else if(inGrid[0][currentPos.y] === 0)\n        {\n            availableSpaces.push({x:0, y:currentPos.y});\n        }\n        \n        if(currentPos.y > 0)\n        {\n            if(inGrid[currentPos.x][currentPos.y - 1] === 0)\n            {\n                availableSpaces.push({x:currentPos.x, y:currentPos.y - 1});\n            }\n        }\n        else if(inGrid[currentPos.x][height - 1] === 0)\n        {\n            availableSpaces.push({x:currentPos.x,y: height - 1});\n        }\n        \n        if(currentPos.y < height - 1)\n        {\n            if(inGrid[currentPos.x][currentPos.y + 1] === 0)\n            {\n                availableSpaces.push({x:currentPos.x,y: currentPos.y + 1});\n            }\n        }\n        else if(inGrid[currentPos.x][0] === 0)\n        {\n            availableSpaces.push({x:currentPos.x, y:0});\n        }\n        //  console.log(availableSpaces)\n        return availableSpaces;\n    }\n    \n    \n  useEffect(() => {\n    let canvas = null;\n    let ctx = null;\n    let width; //canvas width\n    let height; //canvas height\n    let drawImageToCanvas =()=>\n    {\n      \n        canvas = document.getElementById('canvas'); // Get the HTML element with the ID of 'canvas'\n        width = canvas.width;\n        height = canvas.height;\n        ctx = canvas.getContext('2d'); // This is necessary, but I don't know exactly what it does\n        \n        imageData = ctx.createImageData(width,height); //Needed to do pixel manipulation\n        \n       \n       \n        prevPositions = []; //Array of previous positions, used for the recursive backtracker algorithm\n        let colorObj ={}\n        for(let r = 0; r < colorSteps; r++)\n        {\n            for(let g = 0; g < colorSteps; g++)\n            {\n                for(let b = 0; b < colorSteps; b++)\n                {\n                    colorObj={\n                        r:Math.floor(r * 255 / (colorSteps - 1)),\n                        g:Math.floor(g * 255 / (colorSteps - 1)),\n                        b:Math.floor(b * 255 / (colorSteps - 1))\n                    }\n                    colors.push(colorObj)\n                    \n                }\n            }\n        }\n        \n  \n        for(let x = 0; x < width; x++)\n        {\n            grid.push([]);\n            for(let y = 0; y < height; y++)\n            {\n                grid[x].push(0); //Set up the grid\n              \n            }\n        }\n       \n        currentPos = {x:Math.floor(Math.random() * width),y:Math.floor(Math.random() * height)}; \n        \n        grid[currentPos.x][currentPos.y] = 1;\n       \n        prevPositions.push(currentPos);\n                  \n            do\n            {\n                let notFilled = true;\n                while(notFilled)\n                {\n                     let availableSpaces = CheckForSpaces(grid,width,height);\n                    \n                    if(availableSpaces.length > 0)\n                    {\n                         let test = availableSpaces[Math.floor(Math.random() * availableSpaces.length)];\n                         prevPositions.push(currentPos);\n                         currentPos = test;\n                         grid[currentPos.x][currentPos.y] = 1;\n                        let colorPop =colors && colors.pop()\n                        // console.log(colorPop)\n                        imageData.data[((currentPos.x + (currentPos.y * width)) * 4) + 0] = colorPop.r;\n                        imageData.data[((currentPos.x + (currentPos.y * width)) * 4) + 1] = colorPop.g;\n                        imageData.data[((currentPos.x + (currentPos.y * width)) * 4) + 2] = colorPop.b;\n                        imageData.data[((currentPos.x + (currentPos.y * width)) * 4) + 3] = 255;\n                       \n                        notFilled = false;\n                    }\n                    else\n                    {\n                        if(prevPositions.length !==0)\n                        {\n                            currentPos = prevPositions.pop();\n                        }\n                        else\n                        {\n                            break;\n                        }\n                    }\n                }\n            }\n            while(prevPositions.length > 0)\n            ctx.putImageData(imageData,0,0);\n        \n       \n    }\n    \n    drawImageToCanvas();\n  }, []);\n\n  return (\n    <div>\n<canvas id=\"canvas\" width=\"256\" height=\"128\">\n        Sorry your browser does not support Canvas, try Firefox or Chrome!\t\n    </canvas>\n  </div>\n  )\n}\n\n\nexport default Canvas;\n","\nimport './App.css';\n\n import Canvas from './Component/Canvas';\n\nfunction App() {\n  return (\n    <div className=\"App\">\n     \n      <Canvas/>\n    </div>\n  );\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}